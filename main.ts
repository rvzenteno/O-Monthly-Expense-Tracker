import {
    App,
    Plugin,
    PluginSettingTab,
    Setting,
    TFile,
    WorkspaceLeaf,
    ItemView,
    Notice,
    Modal,
    moment,
    Menu
} from 'obsidian';

interface RecurringExpense {
    id: string;
    name: string;
    amount: number;
    currency?: string; // e.g., 'USD', 'BOB'
    dueDay: number; // Day of month (1-31)
    paymentMethod: string;
    startDate: string; // YYYY-MM format
    endDate?: string; // YYYY-MM format, optional
    archived: boolean;
    category?: string;
}

interface OneTimeExpense {
    id: string;
    name: string;
    amount: number;
    currency?: string; // e.g., 'USD', 'BOB'
    date: string; // YYYY-MM-DD
    paymentMethod: string;
    paid: boolean;
    paidDate?: string;
    category?: string;
    confirmationNumber?: string;
}

interface MonthlyPayment {
    expenseId: string;
    month: string; // YYYY-MM format
    paid: boolean;
    paidDate?: string;
    confirmationNumber?: string;
    notes?: string;
}

interface ExpenseTrackerSettings {
    recurringExpenses: RecurringExpense[];
    oneTimeExpenses: OneTimeExpense[];
    monthlyPayments: MonthlyPayment[];
    monthlyNotesFolder: string;
    monthlyNoteTemplate: string;
    autoCreateMonthlyNotes: boolean;
    showStatusBar: boolean;
}

const DEFAULT_SETTINGS: ExpenseTrackerSettings = {
    recurringExpenses: [],
    oneTimeExpenses: [],
    monthlyPayments: [],
    monthlyNotesFolder: 'Monthly Expenses',
    monthlyNoteTemplate: '# {{month}} - Monthly Expenses\n\n## Expense Tracker\n\n{{expenses}}\n\n---\n*Generated by Monthly Expense Tracker*',
    autoCreateMonthlyNotes: true,
    showStatusBar: true
};

const VIEW_TYPE_DASHBOARD = 'expense-tracker-dashboard';
const VIEW_TYPE_CALENDAR = 'expense-tracker-calendar';

export default class MonthlyExpenseTrackerPlugin extends Plugin {
    settings: ExpenseTrackerSettings;
    statusBarItem: HTMLElement;

    async onload() {
        await this.loadSettings();

        // Register views
        this.registerView(
            VIEW_TYPE_DASHBOARD,
            (leaf) => new DashboardView(leaf, this)
        );

        // Add ribbon icon
        this.addRibbonIcon('wallet', 'Monthly Expense Tracker', () => {
            this.activateDashboardView();
        });

        // Add commands
        this.addCommand({
            id: 'open-expense-dashboard',
            name: 'Open Expense Dashboard',
            callback: () => {
                this.activateDashboardView();
            }
        });

        this.addCommand({
            id: 'add-recurring-expense',
            name: 'Add Expense',
            callback: () => {
                new AddExpenseModal(this.app, this, null).open();
            }
        });

        this.addCommand({
            id: 'create-current-month-note',
            name: 'Create Current Month Note',
            callback: async () => {
                const currentMonth = moment().format('YYYY-MM');
                await this.createMonthlyNote(currentMonth);
            }
        });

        this.addCommand({
            id: 'generate-expense-report',
            name: 'Generate Expense Report',
            callback: () => {
                new ReportModal(this.app, this).open();
            }
        });

        // Status bar
        if (this.settings.showStatusBar) {
            this.statusBarItem = this.addStatusBarItem();
            this.updateStatusBar();
        }

        // Auto-create monthly note if needed
        if (this.settings.autoCreateMonthlyNotes) {
            this.checkAndCreateMonthlyNote();
        }

        // Settings tab
        this.addSettingTab(new ExpenseTrackerSettingTab(this.app, this));

        console.log('Monthly Expense Tracker plugin loaded');
    }

    async activateDashboardView() {
        const { workspace } = this.app;

        let leaf = workspace.getLeavesOfType(VIEW_TYPE_DASHBOARD)[0];

        if (!leaf) {
            const newLeaf = workspace.getLeaf('tab');
            if (newLeaf) {
                await newLeaf.setViewState({
                    type: VIEW_TYPE_DASHBOARD,
                    active: true
                });
                leaf = newLeaf;
            }
        }

        if (leaf) {
            workspace.revealLeaf(leaf);
        }
    }

    async checkAndCreateMonthlyNote() {
        const currentMonth = moment().format('YYYY-MM');
        const monthlyNote = await this.getMonthlyNoteFile(currentMonth);

        if (!monthlyNote) {
            await this.createMonthlyNote(currentMonth);
        }
    }

    async createMonthlyNote(month: string): Promise<TFile> {
        const folderPath = this.settings.monthlyNotesFolder;
        const fileName = `${month}.md`;
        const filePath = `${folderPath}/${fileName}`;

        // Ensure folder exists
        const folder = this.app.vault.getAbstractFileByPath(folderPath);
        if (!folder) {
            await this.app.vault.createFolder(folderPath);
        }

        // Check if file already exists
        let file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof TFile) {
            new Notice(`Monthly note for ${month} already exists`);
            return file;
        }

        // Get recurring expenses for this month
        const expenses = this.getExpensesForMonth(month);

        // Get one-time expenses for this month
        const oneTimeExpenses = this.getOneTimeExpensesForMonth(month);

        // Copy unpaid expenses from previous month
        const prevMonth = moment(month, 'YYYY-MM').subtract(1, 'month').format('YYYY-MM');
        const unpaidFromPrev = this.getUnpaidExpenses(prevMonth);

        // Generate expense list
        let expenseList = '## Recurring Expenses\n\n';
        expenses.forEach(expense => {
            const payment = this.getPayment(expense.id, month);
            const status = payment?.paid ? 'x' : ' ';
            const statusIcon = payment?.paid ? '‚úÖ' : '‚¨ú';
            const cur = expense.currency || 'USD';
            let symbol = cur + ' ';
            if (cur === 'USD') symbol = '$';
            else if (cur === 'BOB') symbol = 'Bs ';
            else if (cur === 'EUR') symbol = '‚Ç¨';
            else if (cur === 'GBP') symbol = '¬£';

            expenseList += `- [${status}] ${statusIcon} **${expense.name}** - ${symbol}${expense.amount.toFixed(2)} - Due: ${expense.dueDay} - Method: ${expense.paymentMethod}\n`;
            expenseList += `  - ID: \`${expense.id}\`\n`;
            if (payment?.confirmationNumber) {
                expenseList += `  - Confirmation: ${payment.confirmationNumber}\n`;
            }
            expenseList += '\n';
        });

        if (oneTimeExpenses.length > 0) {
            expenseList += '## One-Time Expenses\n\n';
            oneTimeExpenses.forEach(expense => {
                const status = expense.paid ? 'x' : ' ';
                const statusIcon = expense.paid ? '‚úÖ' : '‚¨ú';
                const cur = expense.currency || 'USD';
                let symbol = cur + ' ';
                if (cur === 'USD') symbol = '$';
                else if (cur === 'BOB') symbol = 'Bs ';
                else if (cur === 'EUR') symbol = '‚Ç¨';
                else if (cur === 'GBP') symbol = '¬£';

                expenseList += `- [${status}] ${statusIcon} **${expense.name}** - ${symbol}${expense.amount.toFixed(2)} - Date: ${expense.date} - Method: ${expense.paymentMethod}\n`;
                expenseList += `  - ID: \`${expense.id}\`\n`;
                if (expense.confirmationNumber) {
                    expenseList += `  - Confirmation: ${expense.confirmationNumber}\n`;
                }
                expenseList += '\n';
            });
        }

        if (unpaidFromPrev.length > 0) {
            expenseList += '\n## Unpaid from Previous Month\n\n';
            unpaidFromPrev.forEach(expense => {
                const symbol = (expense.currency || 'USD') === 'USD' ? '$' : ((expense.currency || 'USD') === 'BOB' ? 'Bs ' : `${expense.currency} `);
                expenseList += `- [ ] ‚ö†Ô∏è **${expense.name}** - ${symbol}${expense.amount.toFixed(2)} - OVERDUE\n`;
                expenseList += `  - ID: \`${expense.id}\`\n\n`;
            });
        }

        // If no expenses, add a helpful message
        if (expenses.length === 0 && oneTimeExpenses.length === 0) {
            expenseList += '\n*No expenses set up for this month yet. Click "**+ Add Expense**" in the dashboard to add expenses.*\n\n';
        }

        // Generate content from template
        const content = this.settings.monthlyNoteTemplate
            .replace('{{month}}', moment(month, 'YYYY-MM').format('MMMM YYYY'))
            .replace('{{expenses}}', expenseList);

        // Create file
        file = await this.app.vault.create(filePath, content);
        new Notice(`Created monthly note for ${month}`);

        return file as TFile;
    }

    async getMonthlyNoteFile(month: string): Promise<TFile | null> {
        const filePath = `${this.settings.monthlyNotesFolder}/${month}.md`;
        const file = this.app.vault.getAbstractFileByPath(filePath);
        return file instanceof TFile ? file : null;
    }

    getExpensesForMonth(month: string): RecurringExpense[] {
        return this.settings.recurringExpenses.filter(expense => {
            if (expense.archived) return false;

            const expenseStart = moment(expense.startDate, 'YYYY-MM');
            const expenseEnd = expense.endDate ? moment(expense.endDate, 'YYYY-MM') : null;
            const checkMonth = moment(month, 'YYYY-MM');

            const afterStart = checkMonth.isSameOrAfter(expenseStart);
            const beforeEnd = !expenseEnd || checkMonth.isSameOrBefore(expenseEnd);

            return afterStart && beforeEnd;
        });
    }

    getUnpaidExpenses(month: string): RecurringExpense[] {
        const expenses = this.getExpensesForMonth(month);
        return expenses.filter(expense => {
            const payment = this.getPayment(expense.id, month);
            return !payment || !payment.paid;
        });
    }

    getPayment(expenseId: string, month: string): MonthlyPayment | undefined {
        return this.settings.monthlyPayments.find(
            p => p.expenseId === expenseId && p.month === month
        );
    }

    async markExpensePaid(expenseId: string, month: string, paid: boolean, confirmationNumber?: string) {
        const existingPayment = this.getPayment(expenseId, month);

        if (existingPayment) {
            existingPayment.paid = paid;
            existingPayment.paidDate = paid ? moment().format('YYYY-MM-DD') : undefined;
            existingPayment.confirmationNumber = confirmationNumber;
        } else {
            this.settings.monthlyPayments.push({
                expenseId,
                month,
                paid,
                paidDate: paid ? moment().format('YYYY-MM-DD') : undefined,
                confirmationNumber
            });
        }

        await this.saveSettings();
        this.updateStatusBar();
    }

    async addRecurringExpense(expense: RecurringExpense) {
        this.settings.recurringExpenses.push(expense);
        await this.saveSettings();
        new Notice(`Added recurring expense: ${expense.name}`);
    }

    async addOneTimeExpense(expense: OneTimeExpense) {
        this.settings.oneTimeExpenses.push(expense);
        await this.saveSettings();
        new Notice(`Added one-time expense: ${expense.name}`);
    }

    getOneTimeExpensesForMonth(month: string): OneTimeExpense[] {
        return this.settings.oneTimeExpenses.filter(expense => {
            const expenseDate = moment(expense.date);
            return expenseDate.format('YYYY-MM') === month;
        });
    }

    async markOneTimeExpensePaid(expenseId: string, paid: boolean, confirmationNumber?: string) {
        const expense = this.settings.oneTimeExpenses.find(e => e.id === expenseId);
        if (expense) {
            expense.paid = paid;
            expense.paidDate = paid ? moment().format('YYYY-MM-DD') : undefined;
            if (confirmationNumber) expense.confirmationNumber = confirmationNumber;
            await this.saveSettings();
            this.updateStatusBar();
        }
    }

    async updateOneTimeExpense(expense: OneTimeExpense) {
        const index = this.settings.oneTimeExpenses.findIndex(e => e.id === expense.id);
        if (index !== -1) {
            this.settings.oneTimeExpenses[index] = expense;
            await this.saveSettings();
            new Notice(`Updated expense: ${expense.name}`);
        }
    }

    async deleteOneTimeExpense(expenseId: string) {
        this.settings.oneTimeExpenses = this.settings.oneTimeExpenses.filter(e => e.id !== expenseId);
        await this.saveSettings();
        new Notice('Expense deleted');
    }

    async updateRecurringExpense(expense: RecurringExpense) {
        const index = this.settings.recurringExpenses.findIndex(e => e.id === expense.id);
        if (index !== -1) {
            this.settings.recurringExpenses[index] = expense;
            await this.saveSettings();
            new Notice(`Updated expense: ${expense.name}`);
        }
    }

    async archiveExpense(expenseId: string) {
        const expense = this.settings.recurringExpenses.find(e => e.id === expenseId);
        if (expense) {
            expense.archived = true;
            await this.saveSettings();
            new Notice(`Archived expense: ${expense.name}`);
        }
    }

    async deleteExpense(expenseId: string) {
        this.settings.recurringExpenses = this.settings.recurringExpenses.filter(e => e.id !== expenseId);
        this.settings.monthlyPayments = this.settings.monthlyPayments.filter(p => p.expenseId !== expenseId);
        await this.saveSettings();
        new Notice('Expense deleted');
    }

    updateStatusBar() {
        if (!this.statusBarItem) return;

        const currentMonth = moment().format('YYYY-MM');
        const unpaid = this.getUnpaidExpenses(currentMonth);
        const recurringTotal = this.getExpensesForMonth(currentMonth).length;

        // One time expenses
        const oneTime = this.getOneTimeExpensesForMonth(currentMonth);
        const oneTimeUnpaid = oneTime.filter(e => !e.paid);

        const totalUnpaidCount = unpaid.length + oneTimeUnpaid.length;
        const totalCount = recurringTotal + oneTime.length;

        if (totalUnpaidCount > 0) {
            this.statusBarItem.textContent = `üí≥ ${totalUnpaidCount}/${totalCount} unpaid`;
            this.statusBarItem.classList.add('expense-tracker-unpaid');
        } else if (totalCount > 0) {
            this.statusBarItem.textContent = `üí≥ All paid`;
            this.statusBarItem.classList.remove('expense-tracker-unpaid');
        } else {
            this.statusBarItem.textContent = 'üí≥';
        }
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);

        // Refresh dashboard if open
        const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_DASHBOARD);
        leaves.forEach(leaf => {
            if (leaf.view instanceof DashboardView) {
                leaf.view.refresh();
            }
        });
    }

    onunload() {
        console.log('Monthly Expense Tracker plugin unloaded');
    }
}
// Dashboard View
class DashboardView extends ItemView {
    plugin: MonthlyExpenseTrackerPlugin;
    currentMonth: string;

    constructor(leaf: WorkspaceLeaf, plugin: MonthlyExpenseTrackerPlugin) {
        super(leaf);
        this.plugin = plugin;
        this.currentMonth = moment().format('YYYY-MM');
    }

    getViewType(): string {
        return VIEW_TYPE_DASHBOARD;
    }

    getDisplayText(): string {
        return 'Expense Dashboard';
    }

    getIcon(): string {
        return 'wallet';
    }

    async onOpen() {
        this.refresh();
    }

    refresh() {
        const container = this.containerEl.children[1];
        container.empty();
        container.addClass('expense-tracker-dashboard');

        // Header
        const header = container.createDiv('expense-tracker-header');
        header.createEl('h2', { text: 'Monthly Expense Tracker' });

        // Month selector
        const monthSelector = container.createDiv('expense-tracker-month-selector');

        const prevBtn = monthSelector.createEl('button', { text: '‚óÄ' });
        prevBtn.onclick = () => {
            this.currentMonth = moment(this.currentMonth, 'YYYY-MM').subtract(1, 'month').format('YYYY-MM');
            this.refresh();
        };

        const monthDisplay = monthSelector.createEl('span', {
            text: moment(this.currentMonth, 'YYYY-MM').format('MMMM YYYY'),
            cls: 'expense-tracker-month-display'
        });

        const nextBtn = monthSelector.createEl('button', { text: '‚ñ∂' });
        nextBtn.onclick = () => {
            this.currentMonth = moment(this.currentMonth, 'YYYY-MM').add(1, 'month').format('YYYY-MM');
            this.refresh();
        };

        const todayBtn = monthSelector.createEl('button', { text: 'Today' });
        todayBtn.onclick = () => {
            this.currentMonth = moment().format('YYYY-MM');
            this.refresh();
        };

        // Summary stats
        const recurringExpenses = this.plugin.getExpensesForMonth(this.currentMonth);
        const oneTimeExpenses = this.plugin.getOneTimeExpensesForMonth(this.currentMonth);

        // Calculate totals by currency
        const totals: { [key: string]: { total: number, paid: number, unpaidCount: number } } = {};
        let totalCount = 0;
        let totalUnpaidCount = 0;

        const processExpense = (amount: number, currency: string, paid: boolean) => {
            if (!totals[currency]) totals[currency] = { total: 0, paid: 0, unpaidCount: 0 };
            totals[currency].total += amount;
            if (paid) {
                totals[currency].paid += amount;
            } else {
                totals[currency].unpaidCount++;
                totalUnpaidCount++;
            }
            totalCount++;
        };

        recurringExpenses.forEach(e => {
            const payment = this.plugin.getPayment(e.id, this.currentMonth);
            const isPaid = payment?.paid || false;
            processExpense(e.amount, e.currency || 'USD', isPaid);
        });

        oneTimeExpenses.forEach(e => {
            processExpense(e.amount, e.currency || 'USD', e.paid);
        });

        const summary = container.createDiv('expense-tracker-summary');

        // General Stats
        summary.createDiv('summary-item').innerHTML = `
            <span class="summary-label">Total Expenses:</span>
            <span class="summary-value">${totalCount}</span>
        `;
        summary.createDiv('summary-item').innerHTML = `
            <span class="summary-label">Unpaid Count:</span>
            <span class="summary-value unpaid">${totalUnpaidCount}</span>
        `;

        // Financial Totals per Currency
        const currencies = Object.keys(totals).sort();
        if (currencies.length === 0) {
            summary.createDiv('summary-item').innerHTML = `
                <span class="summary-label">Total Amount:</span>
                <span class="summary-value">$0.00</span>
            `;
        } else {
            const totalsDiv = container.createDiv('summary-totals');
            totalsDiv.style.gridColumn = '1 / -1';
            totalsDiv.style.marginTop = '10px';
            totalsDiv.style.borderTop = '1px solid var(--background-modifier-border)';
            totalsDiv.style.paddingTop = '10px';

            currencies.forEach(currency => {
                // Generic symbol logic: use $ for USD, Bs for BOB, otherwise just the code
                let symbol = currency + ' ';
                if (currency === 'USD') symbol = '$';
                else if (currency === 'BOB') symbol = 'Bs ';
                else if (currency === 'EUR') symbol = '‚Ç¨';
                else if (currency === 'GBP') symbol = '¬£';

                const data = totals[currency];

                const row = totalsDiv.createDiv('currency-row');
                row.style.display = 'flex';
                row.style.justifyContent = 'space-between';
                row.style.marginBottom = '5px';

                row.innerHTML = `
                    <span style="font-weight: bold;">${currency}</span>
                    <span>Total: ${symbol}${data.total.toFixed(2)}</span>
                    <span class="paid">Paid: ${symbol}${data.paid.toFixed(2)}</span>
                    <span class="unpaid">Unpaid: ${symbol}${(data.total - data.paid).toFixed(2)}</span>
                `;
            });
        }

        // Action buttons
        const actions = container.createDiv('expense-tracker-actions');

        const addBtn = actions.createEl('button', { text: '+ Add Expense', cls: 'mod-cta' });
        addBtn.onclick = () => {
            new AddExpenseModal(this.app, this.plugin, null).open();
        };

        const createNoteBtn = actions.createEl('button', { text: 'üìÑ Create Monthly Note' });
        createNoteBtn.onclick = async () => {
            await this.plugin.createMonthlyNote(this.currentMonth);
        };

        const reportBtn = actions.createEl('button', { text: 'üìä Generate Report' });
        reportBtn.onclick = () => {
            new ReportModal(this.app, this.plugin).open();
        };

        const supportBtn = actions.createEl('button', { text: 'üíô Support Plugin' });
        supportBtn.onclick = () => {
            new SupportModal(this.app).open();
        };
        supportBtn.style.background = 'var(--interactive-accent)';
        supportBtn.style.color = 'var(--text-on-accent)';


        // Expense list
        const expenseList = container.createEl('div', { cls: 'expense-tracker-list' });

        if (totalCount === 0) {
            expenseList.createDiv('expense-tracker-empty').setText('No expenses for this month');
        } else {
            // Unpaid Section
            if (totalUnpaidCount > 0) {
                expenseList.createEl('h3', { text: 'Unpaid' });

                // Recurring Unpaid
                recurringExpenses.filter(e => {
                    const payment = this.plugin.getPayment(e.id, this.currentMonth);
                    return !payment?.paid;
                }).forEach(expense => {
                    this.renderRecurringExpenseItem(expenseList, expense);
                });

                // One-Time Unpaid
                oneTimeExpenses.filter(e => !e.paid).forEach(expense => {
                    this.renderOneTimeExpenseItem(expenseList, expense);
                });
            }

            // Paid Section
            if (totalCount - totalUnpaidCount > 0) {
                expenseList.createEl('h3', { text: 'Paid' });

                // Recurring Paid
                recurringExpenses.filter(e => {
                    const payment = this.plugin.getPayment(e.id, this.currentMonth);
                    return payment?.paid;
                }).forEach(expense => {
                    this.renderRecurringExpenseItem(expenseList, expense);
                });

                // One-Time Paid
                oneTimeExpenses.filter(e => e.paid).forEach(expense => {
                    this.renderOneTimeExpenseItem(expenseList, expense);
                });
            }
        }

        // Archived expenses section
        const archivedExpenses = this.plugin.settings.recurringExpenses.filter(e => e.archived);
        if (archivedExpenses.length > 0) {
            const archivedSection = container.createDiv('expense-tracker-archived');
            const archivedHeader = archivedSection.createEl('h3', { text: 'Archived Expenses' });
            archivedHeader.style.cursor = 'pointer';

            const archivedList = archivedSection.createDiv('expense-tracker-archived-list');
            archivedList.style.display = 'none';

            archivedHeader.onclick = () => {
                archivedList.style.display = archivedList.style.display === 'none' ? 'block' : 'none';
            };

            archivedExpenses.forEach(expense => {
                const item = archivedList.createDiv('expense-item archived');
                item.innerHTML = `
                    <div class="expense-name">${expense.name}</div>
                    <div class="expense-details">${expense.currency === 'USD' ? '$' : (expense.currency === 'BOB' ? 'Bs ' : (expense.currency + ' '))}${expense.amount.toFixed(2)} - ${expense.paymentMethod}</div>
                `;

                item.onclick = (e) => {
                    const menu = new Menu();
                    menu.addItem(item => {
                        item.setTitle('Unarchive').onClick(async () => {
                            expense.archived = false;
                            await this.plugin.saveSettings();
                            this.refresh();
                        });
                    });
                    menu.addItem(item => {
                        item.setTitle('Delete').onClick(async () => {
                            await this.plugin.deleteExpense(expense.id);
                            this.refresh();
                        });
                    });
                    menu.showAtMouseEvent(e as MouseEvent);
                };
            });
        }
    }

    renderRecurringExpenseItem(container: HTMLElement, expense: RecurringExpense) {
        const payment = this.plugin.getPayment(expense.id, this.currentMonth);
        const isPaid = payment?.paid || false;
        const isOverdue = expense.dueDay < parseInt(moment().format('D')) && !isPaid && this.currentMonth === moment().format('YYYY-MM');

        const item = container.createDiv('expense-item');
        if (isPaid) item.addClass('paid');
        if (isOverdue) item.addClass('overdue');

        const checkbox = item.createEl('input', { type: 'checkbox' });
        checkbox.checked = isPaid;
        checkbox.onclick = async (e) => {
            e.stopPropagation();
            if (!isPaid) {
                new MarkPaidModal(this.app, this.plugin, expense, this.currentMonth, () => {
                    this.refresh();
                }).open();
            } else {
                await this.plugin.markExpensePaid(expense.id, this.currentMonth, false);
                this.refresh();
            }
        };

        const content = item.createDiv('expense-content');
        const nameDiv = content.createDiv('expense-name');
        nameDiv.setText(expense.name);
        if (isOverdue) {
            nameDiv.createSpan({ text: ' ‚ö†Ô∏è OVERDUE', cls: 'overdue-badge' });
        }

        const details = content.createDiv('expense-details');
        const symbol = (expense.currency || 'USD') === 'USD' ? '$' : ((expense.currency || 'USD') === 'BOB' ? 'Bs ' : `${expense.currency} `);
        details.innerHTML = `
            ${symbol}${expense.amount.toFixed(2)} ‚Ä¢ Due: ${expense.dueDay} ‚Ä¢ ${expense.paymentMethod}
            ${payment?.confirmationNumber ? `<br>Confirmation: ${payment.confirmationNumber}` : ''}
            ${payment?.paidDate ? `<br>Paid: ${payment.paidDate}` : ''}
        `;

        const actions = item.createDiv('expense-actions');
        this.addContextMenu(actions, expense, 'recurring');
    }

    renderOneTimeExpenseItem(container: HTMLElement, expense: OneTimeExpense) {
        const isPaid = expense.paid;
        const expenseDate = moment(expense.date);
        const isOverdue = expenseDate.isBefore(moment(), 'day') && !isPaid;

        const item = container.createDiv('expense-item');
        if (isPaid) item.addClass('paid');
        if (isOverdue) item.addClass('overdue');

        const checkbox = item.createEl('input', { type: 'checkbox' });
        checkbox.checked = isPaid;
        checkbox.onclick = async (e) => {
            e.stopPropagation();
            if (!isPaid) {
                // For one-time expenses, we can just mark/unmark directly or ask for confirmation if needed
                // Reusing MarkPaidModal logic but adapted could be complex, 
                // simpler to just toggle or use a prompt if confirmation # is needed.
                // Let's implement a direct toggle with optional prompt for now or custom modal.
                // To keep it simple for now, direct update. 
                // Actually, let's allow adding confirmation number.

                // Create a simple one-time payment modal or reuse logic?
                // Reuse MarkPaidModal might be tricky due to types.
                // Let's make a mini-modal on the fly or just update.

                await this.plugin.markOneTimeExpensePaid(expense.id, true);
                this.refresh();
            } else {
                await this.plugin.markOneTimeExpensePaid(expense.id, false);
                this.refresh();
            }
        };

        const content = item.createDiv('expense-content');
        const nameDiv = content.createDiv('expense-name');
        nameDiv.setText(expense.name);
        const badge = nameDiv.createSpan({ text: ' (One-Time)', cls: 'expense-type-badge' });
        badge.style.fontSize = '0.8em';
        badge.style.color = 'var(--text-muted)';
        badge.style.marginLeft = '5px';

        if (isOverdue) {
            nameDiv.createSpan({ text: ' ‚ö†Ô∏è OVERDUE', cls: 'overdue-badge' });
        }

        const details = content.createDiv('expense-details');
        const symbol = (expense.currency || 'USD') === 'USD' ? '$' : ((expense.currency || 'USD') === 'BOB' ? 'Bs ' : `${expense.currency} `);
        details.innerHTML = `
            ${symbol}${expense.amount.toFixed(2)} ‚Ä¢ Date: ${expense.date} ‚Ä¢ ${expense.paymentMethod}
            ${expense.confirmationNumber ? `<br>Confirmation: ${expense.confirmationNumber}` : ''}
            ${expense.paidDate ? `<br>Paid: ${expense.paidDate}` : ''}
        `;

        const actions = item.createDiv('expense-actions');
        this.addContextMenu(actions, expense, 'onetime');
    }

    addContextMenu(container: HTMLElement, expense: RecurringExpense | OneTimeExpense, type: 'recurring' | 'onetime') {
        const menuBtn = container.createEl('button', { text: '‚ãÆ' });
        menuBtn.onclick = (e) => {
            e.stopPropagation();
            const menu = new Menu();

            menu.addItem(item => {
                item.setTitle('Edit').setIcon('pencil').onClick(() => {
                    new AddExpenseModal(this.app, this.plugin, expense).open();
                });
            });

            if (type === 'recurring') {
                menu.addItem(item => {
                    item.setTitle('View History').setIcon('history').onClick(() => {
                        new HistoryModal(this.app, this.plugin, expense as RecurringExpense).open();
                    });
                });

                menu.addItem(item => {
                    item.setTitle('Archive').setIcon('archive').onClick(async () => {
                        await this.plugin.archiveExpense(expense.id);
                        this.refresh();
                    });
                });

                menu.addItem(item => {
                    item.setTitle('Delete').setIcon('trash').onClick(async () => {
                        await this.plugin.deleteExpense(expense.id);
                        this.refresh();
                    });
                });
            } else {
                menu.addItem(item => {
                    item.setTitle('Delete').setIcon('trash').onClick(async () => {
                        await this.plugin.deleteOneTimeExpense(expense.id);
                        this.refresh();
                    });
                });
            }

            menu.showAtMouseEvent(e as MouseEvent);
        };
    }

    async onClose() {
        // Cleanup
    }
}

// Add/Edit Expense Modal
class AddExpenseModal extends Modal {
    plugin: MonthlyExpenseTrackerPlugin;
    expense: RecurringExpense | null;
    oneTimeExpense: OneTimeExpense | null;
    type: 'recurring' | 'onetime';

    constructor(app: App, plugin: MonthlyExpenseTrackerPlugin, expense: RecurringExpense | OneTimeExpense | null) {
        super(app);
        this.plugin = plugin;

        // Determine type based on input expense or default to recurring
        if (expense && 'date' in expense) {
            this.oneTimeExpense = expense as OneTimeExpense;
            this.expense = null;
            this.type = 'onetime';
        } else {
            this.expense = expense as RecurringExpense;
            this.oneTimeExpense = null;
            this.type = 'recurring';
        }
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();

        contentEl.createEl('h2', { text: this.expense || this.oneTimeExpense ? 'Edit Expense' : 'Add Expense' });

        const form = contentEl.createDiv('expense-form');

        // Type Toggle (only for new expenses)
        if (!this.expense && !this.oneTimeExpense) {
            new Setting(form)
                .setName('Expense Type')
                .addDropdown(dropdown => {
                    dropdown
                        .addOption('recurring', 'Recurring (Monthly)')
                        .addOption('onetime', 'One-Time')
                        .setValue(this.type)
                        .onChange(async (value) => {
                            this.type = value as 'recurring' | 'onetime';
                            this.onOpen(); // Re-render form
                        });
                });
        }

        // Name
        new Setting(form)
            .setName('Expense Name')
            .addText(text => {
                text.setValue(this.expense?.name || this.oneTimeExpense?.name || '');
                text.inputEl.id = 'expense-name';
            });

        // Currency
        const currencySetting = new Setting(form)
            .setName('Currency')
            .addDropdown(dropdown => {
                dropdown
                    .addOption('USD', 'USD ($)')
                    .addOption('BOB', 'BOB (Bs)')
                    .addOption('EUR', 'EUR (‚Ç¨)')
                    .addOption('GBP', 'GBP (¬£)')
                    .addOption('OTHER', 'Other (Custom)')
                    .setValue(
                        ['USD', 'BOB', 'EUR', 'GBP'].includes(this.expense?.currency || this.oneTimeExpense?.currency || 'USD')
                            ? (this.expense?.currency || this.oneTimeExpense?.currency || 'USD')
                            : 'OTHER'
                    );
                dropdown.selectEl.id = 'expense-currency-select';

                dropdown.onChange((value) => {
                    const customInput = document.getElementById('expense-currency-custom-container');
                    if (customInput) {
                        customInput.style.display = value === 'OTHER' ? 'block' : 'none';
                    }
                });
            });

        // Custom Currency Input
        const customCurrencyDiv = form.createDiv();
        customCurrencyDiv.id = 'expense-currency-custom-container';
        customCurrencyDiv.style.display = ['USD', 'BOB', 'EUR', 'GBP'].includes(this.expense?.currency || this.oneTimeExpense?.currency || 'USD') ? 'none' : 'block';

        new Setting(customCurrencyDiv)
            .setName('Custom Currency Code')
            .setDesc('e.g., CAD, JPY, AUD')
            .addText(text => {
                const current = this.expense?.currency || this.oneTimeExpense?.currency || 'USD';
                text.setValue(['USD', 'BOB', 'EUR', 'GBP'].includes(current) ? '' : current);
                text.inputEl.id = 'expense-currency-custom';
            });

        // Amount
        new Setting(form)
            .setName('Amount')
            .addText(text => {
                text.setValue(this.expense?.amount.toString() || this.oneTimeExpense?.amount.toString() || '');
                text.inputEl.type = 'number';
                text.inputEl.step = '0.01';
                text.inputEl.id = 'expense-amount';
            });

        if (this.type === 'recurring') {
            // Recurring Fields
            new Setting(form)
                .setName('Due Day of Month')
                .setDesc('1-31')
                .addText(text => {
                    text.setValue(this.expense?.dueDay.toString() || '1');
                    text.inputEl.type = 'number';
                    text.inputEl.min = '1';
                    text.inputEl.max = '31';
                    text.inputEl.id = 'expense-due-day';
                });

            new Setting(form)
                .setName('Start Month')
                .setDesc('YYYY-MM format')
                .addText(text => {
                    text.setValue(this.expense?.startDate || moment().format('YYYY-MM'));
                    text.inputEl.id = 'expense-start-date';
                });

            new Setting(form)
                .setName('End Month (Optional)')
                .setDesc('YYYY-MM format - leave empty for ongoing')
                .addText(text => {
                    text.setValue(this.expense?.endDate || '');
                    text.inputEl.id = 'expense-end-date';
                });
        } else {
            // One-Time Fields
            new Setting(form)
                .setName('Date')
                .setDesc('YYYY-MM-DD format')
                .addText(text => {
                    text.setValue(this.oneTimeExpense?.date || moment().format('YYYY-MM-DD'));
                    text.inputEl.type = 'date';
                    text.inputEl.id = 'expense-date';
                });
        }

        // Payment Method
        new Setting(form)
            .setName('Payment Method')
            .addText(text => {
                text.setValue(this.expense?.paymentMethod || this.oneTimeExpense?.paymentMethod || '');
                text.inputEl.id = 'expense-payment-method';
            });

        // Category
        new Setting(form)
            .setName('Category (Optional)')
            .addText(text => {
                text.setValue(this.expense?.category || this.oneTimeExpense?.category || '');
                text.inputEl.id = 'expense-category';
            });

        // Buttons
        const buttonDiv = contentEl.createDiv('modal-button-container');

        const saveBtn = buttonDiv.createEl('button', { text: 'Save', cls: 'mod-cta' });
        saveBtn.onclick = async () => {
            await this.handleSubmit();
        };

        const cancelBtn = buttonDiv.createEl('button', { text: 'Cancel' });
        cancelBtn.onclick = () => {
            this.close();
        };
    }

    async handleSubmit() {
        const name = (document.getElementById('expense-name') as HTMLInputElement).value;

        let currency = (document.getElementById('expense-currency-select') as HTMLInputElement).value;
        if (currency === 'OTHER') {
            currency = (document.getElementById('expense-currency-custom') as HTMLInputElement).value.toUpperCase();
            if (!currency) {
                new Notice('Please enter a custom currency code');
                return;
            }
        }
        const amount = parseFloat((document.getElementById('expense-amount') as HTMLInputElement).value);
        const paymentMethod = (document.getElementById('expense-payment-method') as HTMLInputElement).value;
        const category = (document.getElementById('expense-category') as HTMLInputElement).value;

        if (!name || isNaN(amount) || !paymentMethod) {
            new Notice('Please fill in all required fields');
            return;
        }

        if (this.type === 'recurring') {
            const dueDayStr = (document.getElementById('expense-due-day') as HTMLInputElement).value;
            const startDate = (document.getElementById('expense-start-date') as HTMLInputElement).value;
            const endDate = (document.getElementById('expense-end-date') as HTMLInputElement).value;
            const dueDay = parseInt(dueDayStr);

            if (!dueDay || !startDate) {
                new Notice('Please fill in all required fields for recurring expense');
                return;
            }

            const expense: RecurringExpense = {
                id: this.expense?.id || `exp-${Date.now()}`,
                name,
                amount,
                currency,
                dueDay,
                paymentMethod,
                startDate,
                endDate: endDate || undefined,
                category: category || undefined,
                archived: this.expense?.archived || false
            };

            if (this.expense) {
                await this.plugin.updateRecurringExpense(expense);
            } else {
                await this.plugin.addRecurringExpense(expense);
            }
        } else {
            const date = (document.getElementById('expense-date') as HTMLInputElement).value;

            if (!date) {
                new Notice('Please select a date for the one-time expense');
                return;
            }

            const expense: OneTimeExpense = {
                id: this.oneTimeExpense?.id || `one-${Date.now()}`,
                name,
                amount,
                currency,
                date,
                paymentMethod,
                category: category || undefined,
                paid: this.oneTimeExpense?.paid || false,
                paidDate: this.oneTimeExpense?.paidDate,
                confirmationNumber: this.oneTimeExpense?.confirmationNumber
            };

            if (this.oneTimeExpense) {
                await this.plugin.updateOneTimeExpense(expense);
            } else {
                await this.plugin.addOneTimeExpense(expense);
            }
        }

        this.close();
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}
// Mark Paid Modal
class MarkPaidModal extends Modal {
    plugin: MonthlyExpenseTrackerPlugin;
    expense: RecurringExpense | OneTimeExpense;
    month: string;
    onComplete: () => void;
    isOneTime: boolean;

    constructor(app: App, plugin: MonthlyExpenseTrackerPlugin, expense: RecurringExpense | OneTimeExpense, month: string, onComplete: () => void) {
        super(app);
        this.plugin = plugin;
        this.expense = expense;
        this.month = month;
        this.onComplete = onComplete;
        this.isOneTime = 'date' in expense;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();

        contentEl.createEl('h2', { text: 'Mark as Paid' });
        contentEl.createEl('p', { text: `${this.expense.name} - $${this.expense.amount.toFixed(2)}` });

        const form = contentEl.createDiv();

        new Setting(form)
            .setName('Confirmation Number (Optional)')
            .addText(text => {
                text.inputEl.id = 'confirmation-number';
            });

        const buttonDiv = contentEl.createDiv('modal-button-container');

        const saveBtn = buttonDiv.createEl('button', { text: 'Mark Paid', cls: 'mod-cta' });
        saveBtn.onclick = async () => {
            const confirmationNumber = (document.getElementById('confirmation-number') as HTMLInputElement).value;

            if (this.isOneTime) {
                await this.plugin.markOneTimeExpensePaid(this.expense.id, true, confirmationNumber || undefined);
            } else {
                await this.plugin.markExpensePaid(this.expense.id, this.month, true, confirmationNumber || undefined);
            }

            this.onComplete();
            this.close();
        };

        const cancelBtn = buttonDiv.createEl('button', { text: 'Cancel' });
        cancelBtn.onclick = () => {
            this.close();
        };
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

// History Modal
class HistoryModal extends Modal {
    plugin: MonthlyExpenseTrackerPlugin;
    expense: RecurringExpense;

    constructor(app: App, plugin: MonthlyExpenseTrackerPlugin, expense: RecurringExpense) {
        super(app);
        this.plugin = plugin;
        this.expense = expense;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();

        contentEl.createEl('h2', { text: `Payment History: ${this.expense.name}` });

        const history = this.plugin.settings.monthlyPayments
            .filter(p => p.expenseId === this.expense.id)
            .sort((a, b) => b.month.localeCompare(a.month));

        if (history.length === 0) {
            contentEl.createEl('p', { text: 'No payment history' });
        } else {
            const table = contentEl.createEl('table', { cls: 'expense-history-table' });
            const thead = table.createEl('thead');
            const headerRow = thead.createEl('tr');
            headerRow.createEl('th', { text: 'Month' });
            headerRow.createEl('th', { text: 'Status' });
            headerRow.createEl('th', { text: 'Paid Date' });
            headerRow.createEl('th', { text: 'Confirmation' });

            const tbody = table.createEl('tbody');
            history.forEach(payment => {
                const row = tbody.createEl('tr');
                row.createEl('td', { text: moment(payment.month, 'YYYY-MM').format('MMM YYYY') });
                row.createEl('td', { text: payment.paid ? '‚úÖ Paid' : '‚¨ú Unpaid' });
                row.createEl('td', { text: payment.paidDate || '-' });
                row.createEl('td', { text: payment.confirmationNumber || '-' });
            });
        }

        const closeBtn = contentEl.createEl('button', { text: 'Close' });
        closeBtn.onclick = () => this.close();
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

// Support Modal
class SupportModal extends Modal {
    constructor(app: App) {
        super(app);
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass('expense-tracker-support-modal');

        const header = contentEl.createEl('h2', { text: 'üíô Support Monthly Expense Tracker' });
        header.style.color = 'var(--interactive-accent)';

        contentEl.createEl('p', {
            text: 'Thank you for considering supporting this plugin! Your support helps maintain and improve this tool.'
        });

        // PayPal Section
        const paypalSection = contentEl.createDiv('support-section');
        paypalSection.createEl('h3', { text: 'üí≥ PayPal' });
        paypalSection.createEl('p', { text: 'One-time or recurring donations via PayPal:' });
        const paypalBtn = paypalSection.createEl('a', {
            text: '‚Üí Donate via PayPal',
            href: 'https://www.paypal.com/paypalme/VictorZenteno'
        });
        paypalBtn.addClass('support-link');

        // Crypto Section
        const cryptoSection = contentEl.createDiv('support-section');
        cryptoSection.createEl('h3', { text: 'ü™ô Cryptocurrency (USDC/USDT)' });
        cryptoSection.createEl('p', { text: 'Support with stablecoins on multiple networks:' });

        const cryptoAddresses = cryptoSection.createDiv('crypto-addresses');

        const usdcDiv = cryptoAddresses.createDiv('crypto-address');
        usdcDiv.createEl('strong', { text: 'USDC (Base Network - Low Fees):' });
        const usdcAddress = usdcDiv.createEl('code', { text: '0x1023142d0548b63542f2a4803b6724d4c26b8bda' });
        usdcAddress.style.display = 'block';
        usdcAddress.style.marginTop = '5px';
        usdcAddress.style.padding = '5px';
        usdcAddress.style.background = 'var(--background-secondary)';
        usdcAddress.style.borderRadius = '4px';
        usdcAddress.style.fontSize = '0.85em';
        usdcAddress.style.wordBreak = 'break-all';

        const usdcNote = usdcDiv.createEl('small', { text: 'Also works on: Ethereum, Polygon, Arbitrum, Optimism' });
        usdcNote.style.display = 'block';
        usdcNote.style.marginTop = '3px';
        usdcNote.style.color = 'var(--text-muted)';

        const usdtDiv = cryptoAddresses.createDiv('crypto-address');
        usdtDiv.createEl('strong', { text: 'USDT (Tron TRC-20 - Ultra Low Fees):' });
        const usdtAddress = usdtDiv.createEl('code', { text: 'TAV7qTGgvn8GnYJfXfes73tD2dAPQJ3L2W' });
        usdtAddress.style.display = 'block';
        usdtAddress.style.marginTop = '5px';
        usdtAddress.style.padding = '5px';
        usdtAddress.style.background = 'var(--background-secondary)';
        usdtAddress.style.borderRadius = '4px';
        usdtAddress.style.fontSize = '0.85em';
        usdtAddress.style.wordBreak = 'break-all';

        const cryptoNote = cryptoSection.createEl('p', { text: '‚ö†Ô∏è Important: Double-check the network before sending!' });
        cryptoNote.style.color = 'var(--text-error)';
        cryptoNote.style.fontSize = '0.9em';
        cryptoNote.style.marginTop = '10px';

        const cryptoTip = cryptoSection.createEl('p', { text: 'üí° Tip: Use Tron for USDT or Base for USDC to minimize fees!' });
        cryptoTip.style.fontSize = '0.9em';
        cryptoTip.style.marginTop = '5px';
        cryptoTip.style.color = 'var(--text-muted)';

        // Buy Me a Coffee Section
        const coffeeSection = contentEl.createDiv('support-section');
        coffeeSection.createEl('h3', { text: '‚òï Buy Me a Coffee' });
        coffeeSection.createEl('p', { text: 'Simple, friendly way to support:' });
        const coffeeBtn = coffeeSection.createEl('a', {
            text: '‚Üí Buy Me a Coffee',
            href: 'https://buymeacoffee.com/rvzen'
        });
        coffeeBtn.addClass('support-link');

        // Other ways to support
        const otherSection = contentEl.createDiv('support-section');
        otherSection.createEl('h3', { text: 'üåü Other Ways to Support' });
        const otherList = otherSection.createEl('ul');
        otherList.createEl('li', { text: '‚≠ê Star the GitHub repository' });
        otherList.createEl('li', { text: 'üêõ Report bugs and issues' });
        otherList.createEl('li', { text: 'üí° Suggest new features' });
        otherList.createEl('li', { text: 'üìù Improve documentation' });
        otherList.createEl('li', { text: 'üó£Ô∏è Tell others about the plugin' });

        // Footer
        const footer = contentEl.createDiv('support-footer');
        footer.style.marginTop = '20px';
        footer.style.padding = '15px';
        footer.style.background = 'var(--background-secondary)';
        footer.style.borderRadius = '8px';
        footer.style.textAlign = 'center';
        footer.createEl('p', { text: 'Thank you for your support! üôè' });
        footer.createEl('small', { text: 'All donations help maintain and improve this plugin' });

        // Close button
        const closeBtn = contentEl.createEl('button', { text: 'Close' });
        closeBtn.style.marginTop = '20px';
        closeBtn.style.width = '100%';
        closeBtn.onclick = () => this.close();
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

// Report Modal
class ReportModal extends Modal {
    plugin: MonthlyExpenseTrackerPlugin;

    constructor(app: App, plugin: MonthlyExpenseTrackerPlugin) {
        super(app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();

        contentEl.createEl('h2', { text: 'Expense Report' });

        const form = contentEl.createDiv();

        new Setting(form)
            .setName('Start Month')
            .setDesc('YYYY-MM format')
            .addText(text => {
                text.setValue(moment().subtract(5, 'months').format('YYYY-MM'));
                text.inputEl.id = 'report-start';
            });

        new Setting(form)
            .setName('End Month')
            .setDesc('YYYY-MM format')
            .addText(text => {
                text.setValue(moment().format('YYYY-MM'));
                text.inputEl.id = 'report-end';
            });

        const buttonDiv = contentEl.createDiv('modal-button-container');

        const generateBtn = buttonDiv.createEl('button', { text: 'Generate', cls: 'mod-cta' });
        generateBtn.onclick = () => {
            this.generateReport();
        };

        const cancelBtn = buttonDiv.createEl('button', { text: 'Cancel' });
        cancelBtn.onclick = () => {
            this.close();
        };
    }

    async generateReport() {
        const startMonth = (document.getElementById('report-start') as HTMLInputElement).value;
        const endMonth = (document.getElementById('report-end') as HTMLInputElement).value;

        const report = this.buildReport(startMonth, endMonth);

        // Create report in Monthly Expenses/Expense Reports folder
        const folderPath = `${this.plugin.settings.monthlyNotesFolder}/Expense Reports`;
        const fileName = `Expense Report ${startMonth} to ${endMonth}.md`;
        const filePath = `${folderPath}/${fileName}`;

        // Ensure folder exists
        try {
            const folder = this.app.vault.getAbstractFileByPath(folderPath);
            if (!folder) {
                await this.app.vault.createFolder(folderPath);
            }

            // Create or overwrite the report
            const existingFile = this.app.vault.getAbstractFileByPath(filePath);
            if (existingFile instanceof TFile) {
                await this.app.vault.modify(existingFile, report);
                new Notice('Report updated');
            } else {
                await this.app.vault.create(filePath, report);
                new Notice('Report generated');
            }
            this.close();
        } catch (error) {
            console.error('Error creating report:', error);
            new Notice('Error creating report');
        }
    }

    buildReport(startMonth: string, endMonth: string): string {
        let report = `# Expense Report\n\n`;
        report += `**Period:** ${moment(startMonth, 'YYYY-MM').format('MMM YYYY')} - ${moment(endMonth, 'YYYY-MM').format('MMM YYYY')}\n\n`;
        report += `**Generated:** ${moment().format('YYYY-MM-DD HH:mm')}\n\n---\n\n`;

        const start = moment(startMonth, 'YYYY-MM');
        const end = moment(endMonth, 'YYYY-MM');

        // Aggregate totals by currency
        const totalAmount: { [key: string]: number } = {};
        const totalPaid: { [key: string]: number } = {};
        const totalUnpaid: { [key: string]: number } = {};

        report += `## Monthly Breakdown\n\n`;

        let current = start.clone();
        while (current.isSameOrBefore(end)) {
            const month = current.format('YYYY-MM');
            const recurringExpenses = this.plugin.getExpensesForMonth(month);
            const oneTimeExpenses = this.plugin.getOneTimeExpensesForMonth(month);

            const monthTotals: { [key: string]: { total: number, paid: number } } = {};

            const process = (amount: number, currency: string, paid: boolean) => {
                if (!monthTotals[currency]) monthTotals[currency] = { total: 0, paid: 0 };
                monthTotals[currency].total += amount;
                if (paid) monthTotals[currency].paid += amount;

                // Add to global totals
                if (!totalAmount[currency]) totalAmount[currency] = 0;
                if (!totalPaid[currency]) totalPaid[currency] = 0;
                totalAmount[currency] += amount;
                if (paid) totalPaid[currency] += amount;
            };

            // Recurring
            recurringExpenses.forEach(e => {
                const payment = this.plugin.getPayment(e.id, month);
                process(e.amount, e.currency || 'USD', payment?.paid || false);
            });

            // One-Time
            oneTimeExpenses.forEach(e => {
                process(e.amount, e.currency || 'USD', e.paid);
            });

            report += `### ${current.format('MMMM YYYY')}\n\n`;

            const currencies = Object.keys(monthTotals).sort();
            if (currencies.length === 0) {
                report += `- No expenses\n`;
            } else {
                currencies.forEach(currency => {
                    let symbol = currency + ' ';
                    if (currency === 'USD') symbol = '$';
                    else if (currency === 'BOB') symbol = 'Bs ';
                    else if (currency === 'EUR') symbol = '‚Ç¨';
                    else if (currency === 'GBP') symbol = '¬£';

                    const data = monthTotals[currency];
                    const unpaid = data.total - data.paid;
                    report += `- **${currency}**: Total: ${symbol}${data.total.toFixed(2)} | Paid: ${symbol}${data.paid.toFixed(2)} | Unpaid: ${symbol}${unpaid.toFixed(2)}\n`;
                });
            }
            report += `\n`;

            current.add(1, 'month');
        }

        report += `## Summary\n\n`;
        const allCurrencies = Object.keys(totalAmount).sort();

        if (allCurrencies.length === 0) {
            report += `No expenses found in this period.\n\n`;
        } else {
            allCurrencies.forEach(currency => {
                let symbol = currency + ' ';
                if (currency === 'USD') symbol = '$';
                else if (currency === 'BOB') symbol = 'Bs ';
                else if (currency === 'EUR') symbol = '‚Ç¨';
                else if (currency === 'GBP') symbol = '¬£';

                const total = totalAmount[currency];
                const paid = totalPaid[currency] || 0;
                const unpaid = total - paid;
                const rate = total > 0 ? ((paid / total) * 100).toFixed(1) : '0';

                report += `### ${currency}\n`;
                report += `- **Total Amount:** ${symbol}${total.toFixed(2)}\n`;
                report += `- **Total Paid:** ${symbol}${paid.toFixed(2)}\n`;
                report += `- **Total Unpaid:** ${symbol}${unpaid.toFixed(2)}\n`;
                report += `- **Payment Rate:** ${rate}%\n\n`;
            });
        }
        // Expense breakdown (Recurring only for detailed history usually, but maybe list one-time significant ones?)
        // Let's keep existing breakdown for recurring as they track over time.
        report += `## Recurring Expense Breakdown\n\n`;
        const allExpenses = this.plugin.settings.recurringExpenses.filter(e => !e.archived);
        allExpenses.forEach(expense => {
            const payments = this.plugin.settings.monthlyPayments.filter(p =>
                p.expenseId === expense.id &&
                moment(p.month, 'YYYY-MM').isBetween(start, end, null, '[]')
            );
            const paidCount = payments.filter(p => p.paid).length;
            const totalCount = payments.length;

            const cur = expense.currency || 'USD';
            let symbol = cur + ' ';
            if (cur === 'USD') symbol = '$';
            else if (cur === 'BOB') symbol = 'Bs ';
            else if (cur === 'EUR') symbol = '‚Ç¨';
            else if (cur === 'GBP') symbol = '¬£';

            report += `### ${expense.name}\n\n`;
            report += `- Amount: ${symbol}${expense.amount.toFixed(2)}\n`;
            report += `- Payment Method: ${expense.paymentMethod}\n`;
            report += `- Paid: ${paidCount}/${totalCount} months\n`;
            report += `- Total Paid: ${symbol}${(paidCount * expense.amount).toFixed(2)}\n\n`;
        });

        // Maybe add One-Time list?
        report += `## One-Time Expenses List\n\n`;
        const allOneTime = this.plugin.settings.oneTimeExpenses.filter(e =>
            moment(e.date).isBetween(start, end, null, '[]')
        ).sort((a, b) => a.date.localeCompare(b.date));

        if (allOneTime.length > 0) {
            allOneTime.forEach(e => {
                const status = e.paid ? 'Paid' : 'Unpaid';
                const symbol = (e.currency || 'USD') === 'USD' ? '$' : ((e.currency || 'USD') === 'BOB' ? 'Bs ' : `${e.currency} `);
                report += `- ${e.date}: **${e.name}** - ${symbol}${e.amount.toFixed(2)} (${status})\n`;
            });
        } else {
            report += `No one-time expenses in this period.\n`;
        }

        return report;
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

// Settings Tab
class ExpenseTrackerSettingTab extends PluginSettingTab {
    plugin: MonthlyExpenseTrackerPlugin;

    constructor(app: App, plugin: MonthlyExpenseTrackerPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'Monthly Expense Tracker Settings' });

        // Support Section
        const supportSection = containerEl.createDiv('expense-tracker-support-section');
        supportSection.style.padding = '20px';
        supportSection.style.marginBottom = '20px';
        supportSection.style.background = 'var(--background-secondary)';
        supportSection.style.borderRadius = '8px';
        supportSection.style.border = '2px solid var(--interactive-accent)';

        const supportHeader = supportSection.createEl('h3', { text: 'üíô Support This Plugin' });
        supportHeader.style.marginTop = '0';
        supportHeader.style.color = 'var(--interactive-accent)';

        supportSection.createEl('p', {
            text: 'If you find this plugin helpful, consider supporting its development!'
        });

        const supportLinks = supportSection.createDiv();
        supportLinks.style.display = 'flex';
        supportLinks.style.gap = '10px';
        supportLinks.style.flexWrap = 'wrap';
        supportLinks.style.marginTop = '10px';

        // PayPal button
        const paypalBtn = supportLinks.createEl('a', {
            text: 'üí≥ PayPal',
            href: 'https://www.paypal.com/paypalme/VictorZenteno'
        });
        paypalBtn.style.cssText = 'padding: 8px 16px; background: var(--interactive-accent); color: var(--text-on-accent); border-radius: 4px; text-decoration: none; font-weight: 600;';

        // Crypto button
        const cryptoBtn = supportLinks.createEl('button', {
            text: 'ü™ô USDC/USDT'
        });
        cryptoBtn.style.cssText = 'padding: 8px 16px; background: var(--interactive-accent); color: var(--text-on-accent); border-radius: 4px; text-decoration: none; font-weight: 600; cursor: pointer; border: none;';
        cryptoBtn.onclick = () => {
            new SupportModal(this.app).open();
        };

        // Buy Me a Coffee button
        const coffeeBtn = supportLinks.createEl('a', {
            text: '‚òï Coffee',
            href: 'https://buymeacoffee.com/rvzen'
        });
        coffeeBtn.style.cssText = 'padding: 8px 16px; background: var(--interactive-accent); color: var(--text-on-accent); border-radius: 4px; text-decoration: none; font-weight: 600;';

        const supportNote = supportSection.createEl('p', {
            text: 'Your support helps maintain and improve this plugin. Thank you! üôè'
        });
        supportNote.style.marginBottom = '0';
        supportNote.style.fontSize = '0.9em';
        supportNote.style.color = 'var(--text-muted)';
        supportNote.style.marginTop = '10px';

        containerEl.createEl('hr', { cls: 'expense-tracker-divider' });
        containerEl.createEl('h2', { text: 'Plugin Settings' });

        new Setting(containerEl)
            .setName('Monthly Notes Folder')
            .setDesc('Folder where monthly expense notes will be created')
            .addText(text => text
                .setValue(this.plugin.settings.monthlyNotesFolder)
                .onChange(async (value) => {
                    this.plugin.settings.monthlyNotesFolder = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Auto-create Monthly Notes')
            .setDesc('Automatically create monthly notes when a new month begins')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoCreateMonthlyNotes)
                .onChange(async (value) => {
                    this.plugin.settings.autoCreateMonthlyNotes = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Show Status Bar')
            .setDesc('Display unpaid expense count in status bar')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showStatusBar)
                .onChange(async (value) => {
                    this.plugin.settings.showStatusBar = value;
                    await this.plugin.saveSettings();

                    if (value && !this.plugin.statusBarItem) {
                        this.plugin.statusBarItem = this.plugin.addStatusBarItem();
                        this.plugin.updateStatusBar();
                    } else if (!value && this.plugin.statusBarItem) {
                        this.plugin.statusBarItem.remove();
                    }
                }));

        new Setting(containerEl)
            .setName('Monthly Note Template')
            .setDesc('Template for monthly notes. Use {{month}} and {{expenses}} as placeholders.')
            .addTextArea(text => {
                text.setValue(this.plugin.settings.monthlyNoteTemplate);
                text.inputEl.rows = 10;
                text.inputEl.cols = 50;
                text.onChange(async (value) => {
                    this.plugin.settings.monthlyNoteTemplate = value;
                    await this.plugin.saveSettings();
                });
            });
    }
}
